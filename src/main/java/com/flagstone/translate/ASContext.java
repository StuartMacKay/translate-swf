package com.flagstone.translate;

import java.util.ArrayList;
import java.util.Stack;

import com.flagstone.transform.coder.Context;
    /*
     * The ASInfo class is used to pass state information between nodes when a
     * tree is translated into an equivalent set of action objects and when it
     * is encoded. The context is used for four purposes when encoding a set of
     * nodes: 1. Maintaining the version of Flash that the script implements
     * ensuring compatibility with the programming model supported by the Flash
     * Player. Only ActionScript for Flash 5 and onwards is supported. Tracking
     * the Flash version is important so that changes in the way objects are
     * encoded can be taken into account. 2. Creating a common table of string.
     * Rather than pushing a string onto the stack each time a reference to an
     * identifier or string literal is used in a script, Flash supports a table
     * which contains all the the strings in a script (up to 256). To specify a
     * string the index of the string in the table is pushed onto the stack
     * reducing the size of the script. Flash only generates a string table if
     * any of the identifiers or string literals are used more than once in a
     * script. The boolean flag, useStrings is set to true whenever a literal is
     * referenced more than once indicating that the table should be added to
     * the translated script. 3. Maintaining insertion points for function
     * definitions. When the Flash authoring application compiles ActionScript
     * function definitions are moved to the start of the script. Similarly
     * definitions nested inside a block are moved to the start of the block.
     * This behaviour is maintained when a tree of nodes are translated, to make
     * regression testing against code generated by the Flash authoring
     * application easier. To do this a stack is maintained which contains the
     * nodes representing a complete script or block. The ASNode method,
     * reorder, inserts the tree of nodes that make up the function definition
     * into the array of child nodes maintained by the node on the top of this
     * stack. To preserve the order in which functions are defined each ASNode
     * maintains a private member which is the index into the array of children
     * where the next definition will be inserted. When a start of a new block
     * or function definition is encountered the new node is pushed onto the
     * stack - currently function definitions are only nested inside other
     * function definitions all other definitions are added to the first node in
     * the script. 4. A stack of the different type of nodes being traversed is
     * maintained to allow conditional code generation. For example if a
     * property identifier (_x, _y, _width, etc.) is encountered then normally
     * the value is not added to the string table, unless the property is inside
     * a 'with' statement. As nodes representing the different types of
     * ActionScript statement are traversed the name of the node is pushed onto
     * the stack so the correct context can be determined when translating and
     * encoding nodes lower in the tree.
     */
    public final class ASContext extends Context {
        /*
         * The stack used to track nodes where function definitions are
         * inserted.
         */
        Stack<ASNode> nodes = new Stack<ASNode>();

        /*
         * Array of strings found in a script. The useStrings flag is set when
         * whenever a string is referenced more than once.
         */
        ArrayList<String> strings = new ArrayList<String>(256);
        boolean useStrings = false;

        /*
         * The context stack used to support conditional generation of actions.
         */
        Stack<String> context = new Stack<String>();

        public ASContext(final String encoding, final int version) {
        	super();
        	setEncoding(encoding);
        	put(Context.VERSION, version);
        }

        /*
         * Adds a string to the table if it has not been added previously. Only
         * the first 256 strings are stored in the table. This should rarely be
         * a limitation however.
         * @param str a string representing a string literal, identifier, the
         * name of a property or function.
         */
        void addString(String str) {
            if (strings.contains(str))
                useStrings = true;
            else if (strings.size() < 256) {
                strings.add(str);
            }
        }

        /*
         * Clears the strings table so definitions for event handler are only
         * defined within the scope of the event handler and not across the
         * entire script.
         */
        void clearStrings() {
            strings.clear();
            useStrings = false;
        }
    }

